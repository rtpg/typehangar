# Stubs for django.db.models.query_utils (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from django.utils import tree
from collections import namedtuple

PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct')

class InvalidQuery(Exception): ...

class QueryWrapper:
    contains_aggregate = ...  # type: bool
    data = ...  # type: Any
    def __init__(self, sql, params) -> None: ...
    def as_sql(self, compiler: Optional[Any] = ..., connection: Optional[Any] = ...): ...

class Q(tree.Node):
    AND = ...  # type: str
    OR = ...  # type: str
    default = ...  # type: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def __or__(self, other): ...
    def __and__(self, other): ...
    def __invert__(self): ...
    def clone(self): ...
    def resolve_expression(self, query: Optional[Any] = ..., allow_joins: bool = ..., reuse: Optional[Any] = ..., summarize: bool = ..., for_save: bool = ...): ...
    def refs_aggregate(self, existing_aggregates): ...

class DeferredAttribute:
    field_name = ...  # type: Any
    def __init__(self, field_name, model) -> None: ...
    def __get__(self, instance, owner): ...
    def __set__(self, instance, value): ...

class RegisterLookupMixin:
    def get_lookup(self, lookup_name): ...
    def get_transform(self, lookup_name): ...
    @classmethod
    def register_lookup(cls, lookup, lookup_name: Optional[Any] = ...): ...

def select_related_descend(field, restricted, requested, load_fields, reverse: bool = ...): ...
def deferred_class_factory(model, attrs): ...
def refs_aggregate(lookup_parts, aggregates): ...
def refs_expression(lookup_parts, annotations): ...
def check_rel_lookup_compatibility(model, target_opts, field): ...
