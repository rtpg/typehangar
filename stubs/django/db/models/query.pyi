# Stubs for django.db.models.query (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

REPR_OUTPUT_SIZE = ...  # type: int
EmptyResultSet = ...  # type: Any

class BaseIterable:
    queryset = ...  # type: Any
    def __init__(self, queryset) -> None: ...

class ModelIterable(BaseIterable):
    def __iter__(self): ...

class ValuesIterable(BaseIterable):
    def __iter__(self): ...

class ValuesListIterable(BaseIterable):
    def __iter__(self): ...

class FlatValuesListIterable(BaseIterable):
    def __iter__(self): ...

class QuerySet:
    model = ...  # type: Any
    query = ...  # type: Any
    def __init__(self, model: Optional[Any] = ..., query: Optional[Any] = ..., using: Optional[Any] = ..., hints: Optional[Any] = ...) -> None: ...
    def as_manager(cls): ...
    as_manager = ...  # type: Any
    def __deepcopy__(self, memo): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __bool__(self): ...
    def __nonzero__(self): ...
    def __getitem__(self, k): ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def iterator(self): ...
    def aggregate(self, *args, **kwargs): ...
    def count(self): ...
    def get(self, *args, **kwargs): ...
    def create(self, **kwargs): ...
    def bulk_create(self, objs, batch_size: Optional[Any] = ...): ...
    def get_or_create(self, defaults: Optional[Any] = ..., **kwargs): ...
    def update_or_create(self, defaults: Optional[Any] = ..., **kwargs): ...
    def earliest(self, field_name: Optional[Any] = ...): ...
    def latest(self, field_name: Optional[Any] = ...): ...
    def first(self): ...
    def last(self): ...
    def in_bulk(self, id_list): ...
    def delete(self): ...
    def update(self, **kwargs): ...
    def exists(self): ...
    def raw(self, raw_query, params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ...): ...
    def values(self, *fields): ...
    def values_list(self, *fields, **kwargs): ...
    def dates(self, field_name, kind, order: str = ...): ...
    def datetimes(self, field_name, kind, order: str = ..., tzinfo: Optional[Any] = ...): ...
    def none(self): ...
    def all(self): ...
    def filter(self, *args, **kwargs): ...
    def exclude(self, *args, **kwargs): ...
    def complex_filter(self, filter_obj): ...
    def select_for_update(self, nowait: bool = ...): ...
    def select_related(self, *fields): ...
    def prefetch_related(self, *lookups): ...
    def annotate(self, *args, **kwargs): ...
    def order_by(self, *field_names): ...
    def distinct(self, *field_names): ...
    def extra(self, select: Optional[Any] = ..., where: Optional[Any] = ..., params: Optional[Any] = ..., tables: Optional[Any] = ..., order_by: Optional[Any] = ..., select_params: Optional[Any] = ...): ...
    def reverse(self): ...
    def defer(self, *fields): ...
    def only(self, *fields): ...
    def using(self, alias): ...
    def ordered(self): ...
    ordered = ...  # type: Any
    @property
    def db(self): ...
    value_annotation = ...  # type: bool
    def is_compatible_query_object_type(self, opts, field): ...

class InstanceCheckMeta(type):
    def __instancecheck__(self, instance): ...

class EmptyQuerySet:
    def __init__(self, *args, **kwargs) -> None: ...

class RawQuerySet:
    raw_query = ...  # type: Any
    model = ...  # type: Any
    query = ...  # type: Any
    params = ...  # type: Any
    translations = ...  # type: Any
    def __init__(self, raw_query, model: Optional[Any] = ..., query: Optional[Any] = ..., params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ..., hints: Optional[Any] = ...) -> None: ...
    def resolve_model_init_order(self): ...
    def __iter__(self): ...
    def __getitem__(self, k): ...
    @property
    def db(self): ...
    def using(self, alias): ...
    @property
    def columns(self): ...
    @property
    def model_fields(self): ...

class Prefetch:
    prefetch_through = ...  # type: Any
    prefetch_to = ...  # type: Any
    queryset = ...  # type: Any
    to_attr = ...  # type: Any
    def __init__(self, lookup, queryset: Optional[Any] = ..., to_attr: Optional[Any] = ...) -> None: ...
    def add_prefix(self, prefix): ...
    def get_current_prefetch_through(self, level): ...
    def get_current_prefetch_to(self, level): ...
    def get_current_to_attr(self, level): ...
    def get_current_queryset(self, level): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

def normalize_prefetch_lookups(lookups, prefix: Optional[Any] = ...): ...
def prefetch_related_objects(result_cache, related_lookups): ...
def get_prefetcher(instance, attr): ...
def prefetch_one_level(instances, prefetcher, lookup, level): ...

class RelatedPopulator:
    db = ...  # type: Any
    cols_start = ...  # type: Any
    cols_end = ...  # type: Any
    init_list = ...  # type: Any
    reorder_for_init = ...  # type: Any
    model_cls = ...  # type: Any
    pk_idx = ...  # type: Any
    related_populators = ...  # type: Any
    reverse_cache_name = ...  # type: Any
    cache_name = ...  # type: Any
    def __init__(self, klass_info, select, db) -> None: ...
    def get_deferred_cls(self, klass_info, init_list): ...
    def populate(self, row, from_obj): ...

def get_related_populators(klass_info, select, db): ...
