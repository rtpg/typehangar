# Stubs for django.template.base (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from .exceptions import TemplateSyntaxError as TemplateSyntaxError

TOKEN_TEXT = ...  # type: int
TOKEN_VAR = ...  # type: int
TOKEN_BLOCK = ...  # type: int
TOKEN_COMMENT = ...  # type: int
TOKEN_MAPPING = ...  # type: Any
FILTER_SEPARATOR = ...  # type: str
FILTER_ARGUMENT_SEPARATOR = ...  # type: str
VARIABLE_ATTRIBUTE_SEPARATOR = ...  # type: str
BLOCK_TAG_START = ...  # type: str
BLOCK_TAG_END = ...  # type: str
VARIABLE_TAG_START = ...  # type: str
VARIABLE_TAG_END = ...  # type: str
COMMENT_TAG_START = ...  # type: str
COMMENT_TAG_END = ...  # type: str
TRANSLATOR_COMMENT_MARK = ...  # type: str
SINGLE_BRACE_START = ...  # type: str
SINGLE_BRACE_END = ...  # type: str
UNKNOWN_SOURCE = ...  # type: str
tag_re = ...  # type: Any
logger = ...  # type: Any

class TemplateEncodingError(Exception): ...

class VariableDoesNotExist(Exception):
    msg = ...  # type: Any
    params = ...  # type: Any
    def __init__(self, msg, params: Any = ...) -> None: ...

class Origin:
    name = ...  # type: Any
    template_name = ...  # type: Any
    loader = ...  # type: Any
    def __init__(self, name, template_name: Optional[Any] = ..., loader: Optional[Any] = ...) -> None: ...
    def __eq__(self, other): ...
    @property
    def loader_name(self): ...

class StringOrigin:
    alternative = ...  # type: str
    deprecation_warning = ...  # type: Any

class Template:
    name = ...  # type: Any
    origin = ...  # type: Any
    engine = ...  # type: Any
    source = ...  # type: Any
    nodelist = ...  # type: Any
    def __init__(self, template_string, origin: Optional[Any] = ..., name: Optional[Any] = ..., engine: Optional[Any] = ...) -> None: ...
    def __iter__(self): ...
    def render(self, context): ...
    def compile_nodelist(self): ...
    def get_exception_info(self, exception, token): ...

def linebreak_iter(template_source): ...

class Token:
    lineno = ...  # type: Any
    position = ...  # type: Any
    def __init__(self, token_type, contents, position: Optional[Any] = ..., lineno: Optional[Any] = ...) -> None: ...
    def split_contents(self): ...

class Lexer:
    template_string = ...  # type: Any
    verbatim = ...  # type: bool
    def __init__(self, template_string) -> None: ...
    def tokenize(self): ...
    def create_token(self, token_string, position, lineno, in_tag): ...

class DebugLexer(Lexer):
    def tokenize(self): ...

class Parser:
    tokens = ...  # type: Any
    tags = ...  # type: Any
    filters = ...  # type: Any
    command_stack = ...  # type: Any
    libraries = ...  # type: Any
    origin = ...  # type: Any
    def __init__(self, tokens, libraries: Optional[Any] = ..., builtins: Optional[Any] = ..., origin: Optional[Any] = ...) -> None: ...
    def parse(self, parse_until: Optional[Any] = ...): ...
    def skip_past(self, endtag): ...
    def extend_nodelist(self, nodelist, node, token): ...
    def error(self, token, e): ...
    def invalid_block_tag(self, token, command, parse_until: Optional[Any] = ...): ...
    def unclosed_block_tag(self, parse_until): ...
    def next_token(self): ...
    def prepend_token(self, token): ...
    def delete_first_token(self): ...
    def add_library(self, lib): ...
    def compile_filter(self, token): ...
    def find_filter(self, filter_name): ...

constant_string = ...  # type: Any
filter_raw_string = ...  # type: Any
filter_re = ...  # type: Any

class FilterExpression:
    token = ...  # type: Any
    filters = ...  # type: Any
    var = ...  # type: Any
    def __init__(self, token, parser) -> None: ...
    def resolve(self, context, ignore_failures: bool = ...): ...
    def args_check(name, func, provided): ...
    args_check = ...  # type: Any

def resolve_variable(path, context): ...

class Variable:
    var = ...  # type: Any
    literal = ...  # type: Any
    lookups = ...  # type: Any
    translate = ...  # type: bool
    message_context = ...  # type: Any
    def __init__(self, var) -> None: ...
    def resolve(self, context): ...

class Node:
    must_be_first = ...  # type: bool
    child_nodelists = ...  # type: Any
    token = ...  # type: Any
    def render(self, context): ...
    def render_annotated(self, context): ...
    def __iter__(self): ...
    def get_nodes_by_type(self, nodetype): ...

class NodeList(list):
    contains_nontext = ...  # type: bool
    def render(self, context): ...
    def get_nodes_by_type(self, nodetype): ...

class TextNode(Node):
    s = ...  # type: Any
    def __init__(self, s) -> None: ...
    def render(self, context): ...

def render_value_in_context(value, context): ...

class VariableNode(Node):
    filter_expression = ...  # type: Any
    def __init__(self, filter_expression) -> None: ...
    def render(self, context): ...

kwarg_re = ...  # type: Any

def token_kwargs(bits, parser, support_legacy: bool = ...): ...
